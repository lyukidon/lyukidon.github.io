import{s as L,h as F,i as H,n as $}from"../chunks/scheduler.dd918b38.js";import{S as C,i as k,r as M,u as j,v as w,d as S,t as A,w as P,g as m,s as _,H as b,h as f,A as v,c as h,F as I,k as T,a as c,f as d}from"../chunks/index.94d1baeb.js";import{P as J,g as Z,a as E}from"../chunks/post_layout.2e559c88.js";function q(u){let e,n='<a href="#한자-정규-표현식">한자 정규 표현식</a>',i,r,t=`<pre class="shiki material-default" style="background-color: #263238; color: #EEFFFF" js="true"><div class="language-id">js</div><div class='code-container'><code><div class='line'><span style="color: #89DDFF">&#96;</span><span style="color: #C3E88D">[</span><span style="color: #EEFFFF">一</span><span style="color: #C3E88D">-</span><span style="color: #EEFFFF">鿿</span><span style="color: #C3E88D">]</span><span style="color: #89DDFF">&#96;</span><span style="color: #89DDFF">;</span></div></code></div></pre>`,a,s,x='<a href="#관련-메서드">관련 메서드</a>',g,o,y="<li><p>string.match(regexp) : String</p> <ul><li>일치하는 문자만 출력</li></ul></li> <li><p>string.search(regexp) : String</p> <ul><li>일치하는 첫번째 문자의 위치</li></ul></li> <li><p>string.replace(regexp, “원하는 문자열”) : String</p> <ul><li>일치하는 문자열을 원하는 문자열로 변경</li></ul></li> <li><p>string.split(regexp) : Array</p> <ul><li>일치하는 문자열을 분할하는데 사용</li></ul></li> <li><p>regexp.test(string) : Boolean</p> <ul><li>문자열이 조건과 일치하는지 여부</li></ul></li> <li><p>regexp.exec(string) : Array</p> <ul><li>일치하는 문자의 모든 정보를 배열로 반환</li></ul></li>";return{c(){e=m("h2"),e.innerHTML=n,i=_(),r=new b(!1),a=_(),s=m("h2"),s.innerHTML=x,g=_(),o=m("ul"),o.innerHTML=y,this.h()},l(l){e=f(l,"H2",{id:!0,"data-svelte-h":!0}),v(e)!=="svelte-1kv5wgm"&&(e.innerHTML=n),i=h(l),r=I(l,!1),a=h(l),s=f(l,"H2",{id:!0,"data-svelte-h":!0}),v(s)!=="svelte-f7a5ig"&&(s.innerHTML=x),g=h(l),o=f(l,"UL",{"data-svelte-h":!0}),v(o)!=="svelte-1y2n10n"&&(o.innerHTML=y),this.h()},h(){T(e,"id","한자-정규-표현식"),r.a=a,T(s,"id","관련-메서드")},m(l,p){c(l,e,p),c(l,i,p),r.m(t,l,p),c(l,a,p),c(l,s,p),c(l,g,p),c(l,o,p)},p:$,d(l){l&&(d(e),d(i),r.d(),d(a),d(s),d(g),d(o))}}}function B(u){let e,n;const i=[u[0],D];let r={$$slots:{default:[q]},$$scope:{ctx:u}};for(let t=0;t<i.length;t+=1)r=F(r,i[t]);return e=new J({props:r}),{c(){M(e.$$.fragment)},l(t){j(e.$$.fragment,t)},m(t,a){w(e,t,a),n=!0},p(t,[a]){const s=a&1?Z(i,[a&1&&E(t[0]),a&0&&E(D)]):{};a&2&&(s.$$scope={dirty:a,ctx:t}),e.$set(s)},i(t){n||(S(e.$$.fragment,t),n=!0)},o(t){A(e.$$.fragment,t),n=!1},d(t){P(e,t)}}}const D={title:"정규표현식으로 한자 찾기 + 메서드",image:"",alt:"",created:"2024-03-19T00:00:00.000Z",updated:"2024-03-19T00:00:00.000Z",tags:["regexp"],images:[],slug:"/Javascript/TIL/regexp/kanji/+page.md",path:"/Javascript/TIL/regexp/kanji",toc:[{depth:2,title:"한자 정규 표현식",slug:"한자-정규-표현식"},{depth:2,title:"관련 메서드",slug:"관련-메서드"}]};function U(u,e,n){return u.$$set=i=>{n(0,e=F(F({},e),H(i)))},e=H(e),[e]}class N extends C{constructor(e){super(),k(this,e,U,B,L,{})}}export{N as component};
