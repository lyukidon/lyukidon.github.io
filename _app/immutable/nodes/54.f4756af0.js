import{s as M,h as k,i as A,n as j}from"../chunks/scheduler.dd918b38.js";import{S as w,i as F,r as q,u as J,v as O,d as S,t as U,w as Z,g as c,s as C,h as x,A as v,c as L,a as s,f as u}from"../chunks/index.94d1baeb.js";import{P as z,g as N,a as H}from"../chunks/post_layout.2e559c88.js";function B(d){let e,p="array 와 linked list를 비교 설명 해주세요. ( 코드 구현 해보기 )",r,a,l='<li>참고 : <a href="https://opentutorials.org/module/1335/8821" rel="nofollow noopener noreferrer external" target="_blank">https://opentutorials.org/module/1335/8821</a></li> <li>메모리 구조<ul><li>array : 연결된 공간에 할당<ul><li>장점 : 조회가 빠름 (배열의 인덱스만 알면 바로 조회 가능하기 때문)</li> <li>단점 : 추가 삭제 느림</li></ul></li> <li>linked list : 빈 공간에 데이터를 할당하고, 위치를 저장해 읽어오는 방법 <ul><li>요소<ul><li>Node : 데이터 필드와 링크 필드( 다음 노드를 가리키는 링크 )</li> <li>포인터 : 노드 내부에 다음 또는 이전 노드와의 연결정보를 가짐</li> <li>헤드 : 가장 처음 위치하는 노드</li> <li>테일 : 가장 끝에 위치하는 노드</li></ul></li> <li>종류<ul><li>단방향 링크드 리스트</li> <li>양방향 링크드 리스트</li> <li>원형 링크드 리스트</li> <li>청크 리스트</li></ul></li> <li>장점 : 조회가 느림 (배열의 헤드(가장 처음)가 가리키는 노드를 처음부터 순차적으로 조회하여 알맞은 값을 찾기 때문)</li> <li>단점 : 추가 삭제가 빠름</li></ul></li></ul></li>',i,o,$="array 는 일련, linked list 는 점 과 점 을 연결 => 시간 복잡도 => 언제 어디서 사용해야 할지를 좀 더 찾아보기",g,_,T="array는 연결된 공간에 할당하는 방식, linkedlist는 빈 공간에 데이터를 할당하고 위치를 저장하는 방식입니다. array 는 인",y,f,P="queue : 선입 선출 (FIFO) 선착순",h,m,b=`<li>자바스크립트에서<ul><li>자료 삽입 : 위치 = rear, 메서드 = push()</li> <li>자료 인출 : 위치 = front, 메서드 = shift()</li></ul></li> <li>원형 큐 : 선형 큐의 단점을 보완. 기존 index에서 다음으로 넘어갈 때 (idx + 1) % length</li> <li>우선순위 큐 : 우선순위가 높은 것부터 내보냄</li> <li>데크 : 양방향 삽입/인출 =&gt; 이중 연결 리스트</li> <li>용례<ul><li>티켓 발매</li> <li>너비 우선 탐색 : 깊이가 낮은 노드부터 깊은 노드까지 탐색
stack : 후입선출 (LIFO)</li></ul></li> <li>자바스크립트에서<ul><li>자료 삽입 : push()</li> <li>자료 인출 : pop()</li></ul></li> <li>용례<ul><li>웹 페이지 뒤로 가기</li> <li>실행 취소</li></ul></li>`;return{c(){e=c("p"),e.textContent=p,r=C(),a=c("ul"),a.innerHTML=l,i=C(),o=c("p"),o.textContent=$,g=C(),_=c("p"),_.textContent=T,y=C(),f=c("p"),f.textContent=P,h=C(),m=c("ul"),m.innerHTML=b},l(t){e=x(t,"P",{"data-svelte-h":!0}),v(e)!=="svelte-8iu6j0"&&(e.textContent=p),r=L(t),a=x(t,"UL",{"data-svelte-h":!0}),v(a)!=="svelte-8frxab"&&(a.innerHTML=l),i=L(t),o=x(t,"P",{"data-svelte-h":!0}),v(o)!=="svelte-12z97yt"&&(o.textContent=$),g=L(t),_=x(t,"P",{"data-svelte-h":!0}),v(_)!=="svelte-1r8ujtb"&&(_.textContent=T),y=L(t),f=x(t,"P",{"data-svelte-h":!0}),v(f)!=="svelte-b8p174"&&(f.textContent=P),h=L(t),m=x(t,"UL",{"data-svelte-h":!0}),v(m)!=="svelte-d2kp58"&&(m.innerHTML=b)},m(t,n){s(t,e,n),s(t,r,n),s(t,a,n),s(t,i,n),s(t,o,n),s(t,g,n),s(t,_,n),s(t,y,n),s(t,f,n),s(t,h,n),s(t,m,n)},p:j,d(t){t&&(u(e),u(r),u(a),u(i),u(o),u(g),u(_),u(y),u(f),u(h),u(m))}}}function D(d){let e,p;const r=[d[0],I];let a={$$slots:{default:[B]},$$scope:{ctx:d}};for(let l=0;l<r.length;l+=1)a=k(a,r[l]);return e=new z({props:a}),{c(){q(e.$$.fragment)},l(l){J(e.$$.fragment,l)},m(l,i){O(e,l,i),p=!0},p(l,[i]){const o=i&1?N(r,[i&1&&H(l[0]),i&0&&H(I)]):{};i&2&&(o.$$scope={dirty:i,ctx:l}),e.$set(o)},i(l){p||(S(e.$$.fragment,l),p=!0)},o(l){U(e.$$.fragment,l),p=!1},d(l){Z(e,l)}}}const I={title:"Array와 LinkedList의 차이점",image:"",alt:"",created:"2024-04-16T00:00:00.000Z",updated:"2024-04-16T00:00:00.000Z",tags:["backend"],images:[],slug:"/Javascript/TIL/백엔드기초/Array_LinkedList/+page.md",path:"/Javascript/TIL/백엔드기초/Array_LinkedList",toc:!1};function E(d,e,p){return d.$$set=r=>{p(0,e=k(k({},e),A(r)))},e=A(e),[e]}class R extends w{constructor(e){super(),F(this,e,E,D,M,{})}}export{R as component};
