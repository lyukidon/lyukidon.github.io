import{s as P,h as $,i as T,n as I}from"../chunks/scheduler.dd918b38.js";import{S as J,i as S,r as H,u as L,v as w,d as k,t as M,w as j,g as _,s as y,H as Z,h as v,A as h,c as m,F as q,a as p,f as r}from"../chunks/index.94d1baeb.js";import{P as B,g as O,a as b}from"../chunks/post_layout.697a27d1.js";import{T as U}from"../chunks/table.bde8f6fc.js";function Y(c){let t,o="<tr><th>함수 호출 방식</th> <th>this가 가리키는 값</th></tr>",n,a,e="<tr><td>일반 함수</td> <td>전역 객체</td></tr> <tr><td>메서드</td> <td>메서드를 호출한 객체</td></tr> <tr><td>생성자 함수</td> <td>생성자가 생성할 인스턴스</td></tr>";return{c(){t=_("thead"),t.innerHTML=o,n=y(),a=_("tbody"),a.innerHTML=e},l(s){t=v(s,"THEAD",{"data-svelte-h":!0}),h(t)!=="svelte-16s0d5h"&&(t.innerHTML=o),n=m(s),a=v(s,"TBODY",{"data-svelte-h":!0}),h(a)!=="svelte-1du37mo"&&(a.innerHTML=e)},m(s,d){p(s,t,d),p(s,n,d),p(s,a,d)},p:I,d(s){s&&(r(t),r(n),r(a))}}}function z(c){let t,o="this는 자기 참조 변수이다. this 바인딩은 호출 방식에 따라서 동적으로 결정된다.",n,a,e,s,d=`<pre class="shiki material-default" style="background-color: #263238; color: #EEFFFF" js="true"><div class="language-id">js</div><div class='code-container'><code><div class='line'><span style="color: #C792EA">function</span><span style="color: #EEFFFF"> </span><span style="color: #82AAFF">test</span><span style="color: #EEFFFF"> </span><span style="color: #89DDFF">&#123;&#125;</span></div><div class='line'><span style="color: #C792EA">const</span><span style="color: #EEFFFF"> obj </span><span style="color: #89DDFF">=</span><span style="color: #EEFFFF"> </span><span style="color: #89DDFF">&#123;</span><span style="color: #EEFFFF"> test </span><span style="color: #89DDFF">&#125;</span></div><div class='line'></div><div class='line'><span style="color: #546E7A">// 일반 함수 호출</span></div><div class='line'><span style="color: #82AAFF">test</span><span style="color: #EEFFFF">()</span></div><div class='line'><span style="color: #546E7A">//메서드 호출</span></div><div class='line'><span style="color: #EEFFFF">obj</span><span style="color: #89DDFF">.</span><span style="color: #82AAFF">test</span><span style="color: #EEFFFF">()</span></div><div class='line'><span style="color: #546E7A">//생성자 함수 호출</span></div><div class='line'><span style="color: #C792EA">const</span><span style="color: #EEFFFF"> hello </span><span style="color: #89DDFF">=</span><span style="color: #EEFFFF"> </span><span style="color: #89DDFF">new</span><span style="color: #EEFFFF"> </span><span style="color: #82AAFF">test</span><span style="color: #EEFFFF">()</span><span style="color: #89DDFF">;</span></div></code></div></pre>`,f,F,A="new 연산자를 이용해 호출 시, 생성자 함수로서 동작",E,u,D="<li>this : 자기 참조 변수(자신이 속한 객체 or 자신이 생성할 인스턴스를 가리킴)</li> <li>this 바인딩은 함수 호출 방식에 따라 동적으로 결정</li> <li>strict mode가 영향을 주기도 함</li> <li>호출 방식에 따른 this<ul><li>일반 함수 호출</li> <li>메서드 호출</li> <li>생성자 함수 호출</li> <li>Function.prototype.apply/call/bind메서드에 의한 간접 호출</li></ul></li> <li>일반 함수 호출<ul><li>전역 객체 바인딩</li></ul></li> <li>메서드 호출<ul><li>연산자 앞의 객체가 바인딩 (.prototype도 같다.)</li> <li>일반 함수로 호출 시, 전역 객체</li></ul></li> <li>생성자 함수 호출<ul><li>생성할 인스턴스에 바인딩</li> <li>일반 함수로 호출시는 언제나 전역 객체이다.</li></ul></li> <li>Function.prototype.apply/call/bind메서드에 의한 간접 호출<ul><li>apply<ul><li><code>Function.prototype.apply(thisArg[, argsArray])</code></li> <li>사용법 : <code>foo.apply(thisArg)</code></li> <li>예시 : <code>foo.apply(thisArg, [1, 2, 3, 4])</code></li></ul></li> <li>call<ul><li><code>Function.prototype.apply(thisArg[, arg1[, arg2[, ...]]])</code></li> <li>사용법: <code>foo.apply(thisArg)</code></li> <li>예시 : <code>foo.apply(thisArg, 1, 2, 3, 4)</code></li></ul></li> <li>bind<ul><li>callback 함수의 바인딩을 지정</li></ul></li></ul></li>",g;return a=new U({props:{$$slots:{default:[Y]},$$scope:{ctx:c}}}),{c(){t=_("p"),t.textContent=o,n=y(),H(a.$$.fragment),e=y(),s=new Z(!1),f=y(),F=_("p"),F.textContent=A,E=y(),u=_("ul"),u.innerHTML=D,this.h()},l(l){t=v(l,"P",{"data-svelte-h":!0}),h(t)!=="svelte-6n7k3w"&&(t.textContent=o),n=m(l),L(a.$$.fragment,l),e=m(l),s=q(l,!1),f=m(l),F=v(l,"P",{"data-svelte-h":!0}),h(F)!=="svelte-dhvuk9"&&(F.textContent=A),E=m(l),u=v(l,"UL",{"data-svelte-h":!0}),h(u)!=="svelte-rs5dfk"&&(u.innerHTML=D),this.h()},h(){s.a=f},m(l,i){p(l,t,i),p(l,n,i),w(a,l,i),p(l,e,i),s.m(d,l,i),p(l,f,i),p(l,F,i),p(l,E,i),p(l,u,i),g=!0},p(l,i){const x={};i&2&&(x.$$scope={dirty:i,ctx:l}),a.$set(x)},i(l){g||(k(a.$$.fragment,l),g=!0)},o(l){M(a.$$.fragment,l),g=!1},d(l){l&&(r(t),r(n),r(e),s.d(),r(f),r(F),r(E),r(u)),j(a,l)}}}function G(c){let t,o;const n=[c[0],C];let a={$$slots:{default:[z]},$$scope:{ctx:c}};for(let e=0;e<n.length;e+=1)a=$(a,n[e]);return t=new B({props:a}),{c(){H(t.$$.fragment)},l(e){L(t.$$.fragment,e)},m(e,s){w(t,e,s),o=!0},p(e,[s]){const d=s&1?O(n,[s&1&&b(e[0]),s&0&&b(C)]):{};s&2&&(d.$$scope={dirty:s,ctx:e}),t.$set(d)},i(e){o||(k(t.$$.fragment,e),o=!0)},o(e){M(t.$$.fragment,e),o=!1},d(e){j(t,e)}}}const C={title:"this 바인딩",image:"",alt:"",created:"2024-02-18T00:00:00.000Z",updated:"2024-03-06T00:00:00.000Z",tags:["this"],images:[],slug:"/Javascript/TIL/this/+page.md",path:"/Javascript/TIL/this",toc:!1};function K(c,t,o){return c.$$set=n=>{o(0,t=$($({},t),T(n)))},t=T(t),[t]}class W extends J{constructor(t){super(),S(this,t,K,G,P,{})}}export{W as component};
