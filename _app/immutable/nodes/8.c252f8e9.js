import{s as p,h as o,i as r,n as m}from"../chunks/scheduler.dd918b38.js";import{S as f,i as d,r as g,u as v,v as h,d as $,t as x,w as T,g as L,h as y,A as C,a as P,f as w}from"../chunks/index.94d1baeb.js";import{P as H,g as I,a as c}from"../chunks/post_layout.3594328b.js";function J(i){let e,a="<li><p>클로저</p> <ul><li>함수와 그 함수가 선언된 렉시컬 환경과의 조합</li> <li>함수 내부에서 함수 외부의 값을 참조할 수 있음.</li> <li>중첩되지 않은 함수인 경우는 값을 참조할 수 없음.</li></ul></li> <li><p>정적 스코프(렉시컬 스코프)</p> <ul><li>자바스크립트는 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.</li></ul></li> <li><p>함수 객체의 내부 슬롯</p> <ul><li>렉시컬 스코프 가능하려면, 함수의 상위 스코프(함수가 정의된 환경)을 기억해야 한다.</li> <li>함수는 자신의 내부 슬롯에 상위 스코프의 참조를 저장한다.</li></ul></li> <li><p>클로저와 렉시컬 환경</p> <ul><li>외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주가기 종료한 외부 함수의 변수를 참조할 수 있다. 이런 중첩 함수는 클로저라고 한다.</li> <li>누군가가 참조하고 있는 메모리 공간을 함부로 해제하지 않는다.</li></ul></li> <li><p>클로저 활용</p> <ul><li>상태를 안전하게 변경하고 유지하기 위해 사용</li> <li>상태를 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용</li></ul></li>";return{c(){e=L("ul"),e.innerHTML=a},l(l){e=y(l,"UL",{"data-svelte-h":!0}),C(e)!=="svelte-1v6o0ih"&&(e.innerHTML=a)},m(l,n){P(l,e,n)},p:m,d(l){l&&w(e)}}}function M(i){let e,a;const l=[i[0],_];let n={$$slots:{default:[J]},$$scope:{ctx:i}};for(let t=0;t<l.length;t+=1)n=o(n,l[t]);return e=new H({props:n}),{c(){g(e.$$.fragment)},l(t){v(e.$$.fragment,t)},m(t,s){h(e,t,s),a=!0},p(t,[s]){const u=s&1?I(l,[s&1&&c(t[0]),s&0&&c(_)]):{};s&2&&(u.$$scope={dirty:s,ctx:t}),e.$set(u)},i(t){a||($(e.$$.fragment,t),a=!0)},o(t){x(e.$$.fragment,t),a=!1},d(t){T(e,t)}}}const _={title:"클로저(Closure)",image:"",alt:"",created:"2024-03-12T00:00:00.000Z",updated:"2024-03-12T00:00:00.000Z",tags:["closure"],images:[],slug:"/Javascript/TIL/closure/+page.md",path:"/Javascript/TIL/closure",toc:!1};function S(i,e,a){return i.$$set=l=>{a(0,e=o(o({},e),r(l)))},e=r(e),[e]}class q extends f{constructor(e){super(),d(this,e,S,M,p,{})}}export{q as component};
