import{s as w,h as L,i as M,n as j}from"../chunks/scheduler.dd918b38.js";import{S as y,i as O,r as S,u as V,v as k,d as I,t as J,w as W,g as c,s as C,h as d,A as v,c as h,a as u,f as r}from"../chunks/index.94d1baeb.js";import{P as Z,g as q,a as P}from"../chunks/post_layout.0e7f7691.js";function A(m){let e,o="기존의 벽을 확인하는 방법은 다음과 같았다.",i,n,l="<li><p>평균값을 이용</p> <ul><li>색상의 평균값을 이용해서, 데이터를 계산하고, 평균값보다 높은 경우 데이터를 255로 변경한다.</li></ul></li> <li><p>이진화</p> <ul><li>특정 값 이상의 색을 모두 255로 만들어, 흑과 백만 남긴다.</li></ul></li> <li><p>DFS (깊이 우선 탐색)</p> <ul><li>검은 점이 이어진 부분들을 모두 찾아 벽을 찾으려고 했으나, 1개의 선으로 이어지지 않은 그림의 경우는 사용할 수 없는 문제점이 존재</li></ul></li>",a,s,T="그러나 위와 같은 방법은 어떤 그림에서는 사용할 수 없는 방법이라, 다음과 같은 방법으로 변경",g,_,$="<li><p>색상 제거</p> <ul><li>평균값 =&gt; 중앙값을 사용해보기</li></ul></li> <li><p>이진화</p></li> <li><p>그레이 스케일</p> <ul><li>이미지를 회색으로 만들기 위해서는 (r+g+b)/3 을 해주면 된다.</li></ul></li> <li><p>모폴로지 그레디언트</p> <ul><li>경계 이미지를 추출하는 방법이다.</li></ul></li> <li><p>adaptive threshold</p> <ul><li>잡영(noise) 제거</li></ul></li> <li><p>모폴로지 클로즈</p> <ul><li>끊어진 개체를 연결하거나 구멍을 채우는 연산 작업이다.</li></ul></li>",x,f,H='참고: <a href="https://d2.naver.com/helloworld/8344782" rel="nofollow noopener noreferrer external" target="_blank">딥러닝과 OpenCV를 활용해 사진 속 글자 검출하기</a>';return{c(){e=c("p"),e.textContent=o,i=C(),n=c("ol"),n.innerHTML=l,a=C(),s=c("p"),s.textContent=T,g=C(),_=c("ol"),_.innerHTML=$,x=C(),f=c("p"),f.innerHTML=H},l(t){e=d(t,"P",{"data-svelte-h":!0}),v(e)!=="svelte-1g1p6s9"&&(e.textContent=o),i=h(t),n=d(t,"OL",{"data-svelte-h":!0}),v(n)!=="svelte-1c0rdjk"&&(n.innerHTML=l),a=h(t),s=d(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-1tevhlc"&&(s.textContent=T),g=h(t),_=d(t,"OL",{"data-svelte-h":!0}),v(_)!=="svelte-t8ojb8"&&(_.innerHTML=$),x=h(t),f=d(t,"P",{"data-svelte-h":!0}),v(f)!=="svelte-1gvrrre"&&(f.innerHTML=H)},m(t,p){u(t,e,p),u(t,i,p),u(t,n,p),u(t,a,p),u(t,s,p),u(t,g,p),u(t,_,p),u(t,x,p),u(t,f,p)},p:j,d(t){t&&(r(e),r(i),r(n),r(a),r(s),r(g),r(_),r(x),r(f))}}}function D(m){let e,o;const i=[m[0],b];let n={$$slots:{default:[A]},$$scope:{ctx:m}};for(let l=0;l<i.length;l+=1)n=L(n,i[l]);return e=new Z({props:n}),{c(){S(e.$$.fragment)},l(l){V(e.$$.fragment,l)},m(l,a){k(e,l,a),o=!0},p(l,[a]){const s=a&1?q(i,[a&1&&P(l[0]),a&0&&P(b)]):{};a&2&&(s.$$scope={dirty:a,ctx:l}),e.$set(s)},i(l){o||(I(e.$$.fragment,l),o=!0)},o(l){J(e.$$.fragment,l),o=!1},d(l){W(e,l)}}}const b={title:"평면도의 벽을 확인하는 방법",image:"",alt:"",created:"2024-06-02T00:00:00.000Z",updated:"2024-06-05T00:00:00.000Z",tags:["cv"],images:[],slug:"/Javascript/TIL/CV/findWall/+page.md",path:"/Javascript/TIL/CV/findWall",toc:!1};function F(m,e,o){return m.$$set=i=>{o(0,e=L(L({},e),M(i)))},e=M(e),[e]}class G extends y{constructor(e){super(),O(this,e,F,D,w,{})}}export{G as component};
