import{s as c,h as i,i as m,n as f}from"../chunks/scheduler.dd918b38.js";import{S as d,i as p,r as g,u as v,v as h,d as $,t as x,w as T,g as L,h as y,A as P,a as S,f as w}from"../chunks/index.94d1baeb.js";import{P as C,g as H,a as u}from"../chunks/post_layout.3594328b.js";function I(l){let t,s="<li>오름차순 기준</li> <li>선택정렬 : 처음부터 끝까지 확인해서 제일 작은 수를 앞으로 (1-n번째 확인 ⇒ 1, 2-n번째 ⇒ 2)</li> <li>버블정렬 : 연속된 2개를 비교 ⇒ 그 다음 순서의 2개 비교 ⇒ 맨 뒤에 큰 수</li> <li>병합정렬 : 배열을 여러 개로 나누어 비교 ⇒ 연속된 배열을 합쳐서 비교 (작은 문제를 비교해, 큰 문제를 해결)</li> <li>삽입정렬 : 2번째 자료부터 시작해, 1번째 부터 비교하여 삽입을 한 후 뒤의 자료를 밀어내는 형식</li> <li>퀵정렬 : 임의의 기준값을 정하고, 한쪽은 기준보다 작은 값 &amp; 다른 한쪽은 기준보다 높은 값을 넣는다. 이 과정을 반복한다.</li> <li>힙정렬 : 이진 트리 구조를 이용하여, 정렬하는 자료구조</li>";return{c(){t=L("ul"),t.innerHTML=s},l(a){t=y(a,"UL",{"data-svelte-h":!0}),P(t)!=="svelte-ffhlmz"&&(t.innerHTML=s)},m(a,o){S(a,t,o)},p:f,d(a){a&&w(t)}}}function J(l){let t,s;const a=[l[0],_];let o={$$slots:{default:[I]},$$scope:{ctx:l}};for(let e=0;e<a.length;e+=1)o=i(o,a[e]);return t=new C({props:o}),{c(){g(t.$$.fragment)},l(e){v(t.$$.fragment,e)},m(e,n){h(t,e,n),s=!0},p(e,[n]){const r=n&1?H(a,[n&1&&u(e[0]),n&0&&u(_)]):{};n&2&&(r.$$scope={dirty:n,ctx:e}),t.$set(r)},i(e){s||($(t.$$.fragment,e),s=!0)},o(e){x(t.$$.fragment,e),s=!1},d(e){T(t,e)}}}const _={title:"Sorting",image:"",alt:"",created:"2024-04-11T00:00:00.000Z",updated:"2024-04-11T00:00:00.000Z",tags:["sorting"],images:[],slug:"/Javascript/TIL/sorting/+page.md",path:"/Javascript/TIL/sorting",toc:!1};function M(l,t,s){return l.$$set=a=>{s(0,t=i(i({},t),m(a)))},t=m(t),[t]}class q extends d{constructor(t){super(),p(this,t,M,J,c,{})}}export{q as component};
